package parser;
import parser.Parser.*;
import java.util.*; // HashMap, LinkedList

public class Common {

   /*
    * parser.Common parts to parser and scanner
    * - Token are generated by the lexer, which here are only simulated.
    * - The Scanner only converts read tokens as enums.
    * - Order tokens as the columns of parse table
    */
   
   public static enum Token { 
      PLUS,MULT,ZERO, EOF, EMPTY
   }   

   public static final HashMap<String, Token> TOKEN_NO = 
         new HashMap<String, Token>();
 
   static {
      TOKEN_NO.put("+", Token.PLUS);
      TOKEN_NO.put("*", Token.MULT);
      TOKEN_NO.put("0", Token.ZERO);
      TOKEN_NO.put("$", Token.EOF);
      TOKEN_NO.put("",  Token.EMPTY); // So empty without me.
   }
   
   /* Gramática
    * - Solução Q&D: array
    * - Não terminais enumerados pelo enum NonTerm 
    * - As regras são enumeradas pela ordem que aparecem em linha
    */
   
   public enum NonTerm { 
      S, E, B
   }   
   
   public Parser.IGrammar g = new Parser.IGrammar() {
      @SuppressWarnings("rawtypes")
      Enum[][] grammar = 
         { 
           /* r0 */  { NonTerm.S, /*::=*/  NonTerm.E, Token.EOF},
           /* r1 */  { NonTerm.E, /*::=*/  NonTerm.E, Token.MULT,NonTerm.B},
           /* r2 */  { NonTerm.E, /*::=*/  NonTerm.E, Token.PLUS,NonTerm.B},
           /* r3 */  { NonTerm.E, /*::=*/  NonTerm.B},
           /* r4 */  { NonTerm.B, /*::=*/  Token.ZERO}
         };
      @SuppressWarnings("rawtypes")
      @Override
      public Enum lhs(int ruleNo) { return grammar[ruleNo][0]; }
      @Override
      public int noSymRHS(int ruleNo) { return grammar[ruleNo].length - 1; }
   };

   /* Parser table
    * - Quick and dirty solution: array
    * - Define your table as an array using abbreviations
    *   given by Parser.ActionTo.
    * - Leave getState() and lastState() as they are.  
    */
   Parser.ITable tbl = new Parser.ITable() {
      // Abbreviations
      private final Parser.ActionTo 
            // Shifts
            s3  = new Parser.ActionTo(Parser.Action.SHIFT, 3),
            s4  = new Parser.ActionTo(Parser.Action.SHIFT, 4),
            s5  = new Parser.ActionTo(Parser.Action.SHIFT, 5),
            s8  = new Parser.ActionTo(Parser.Action.SHIFT, 8),
            s9  = new Parser.ActionTo(Parser.Action.SHIFT, 9),
            // Reduces
            r1  = new Parser.ActionTo(Parser.Action.REDUCE, 1),
            r2  = new Parser.ActionTo(Parser.Action.REDUCE, 2),
            r3  = new Parser.ActionTo(Parser.Action.REDUCE, 3),
            r4  = new Parser.ActionTo(Parser.Action.REDUCE, 4),
            // Gotos
            g1  = new Parser.ActionTo(Parser.Action.GOTO, 1),
            g2  = new Parser.ActionTo(Parser.Action.GOTO, 2),
            g6  = new Parser.ActionTo(Parser.Action.GOTO, 6),
            g7  = new Parser.ActionTo(Parser.Action.GOTO, 7),
            // Etc.
            err = new Parser.ActionTo(Parser.Action.ERROR, 0),
            acc = new Parser.ActionTo(Parser.Action.ACC, 0);
      /* Tabela de parsing: 
       * shift/reduce
       * colunas enumeradas na ordem de enum Token acima
       */
      Parser.ActionTo[][] srtable = 
         { 
           /*          *   +     0    $   */
           /* S0 */  {err, err,  s3, err},
           /* S1 */  { s4,  s5, err, acc},
           /* S2 */  { r3,  r3,  r3,  r3},
           /* S3 */  { r4,  r4,  r4,  r4},
           /* S4 */  {err, err,  s8, err},
           /* S5 */  {err, err,  s9, err},
           /* S6 */  { r1,  r1,  r1,  r1},
           /* S7 */  { r2,  r2,  r2,  r2},
           /* S8 */  { r4,  r4,  r4,  r4},
           /* S9 */  { r4,  r4,  r4,  r4}
         };
      /* Tabela de parsing: 
       * gotos
       * colunas enumeradas na ordem de enum Nonterm acima
       */
      Parser.ActionTo[][] gototable = 
         { 
           /*          S    E    B*/
           /* S0 */  {err,  g1,  g2},
           /* S1 */  {err, err, err},
           /* S2 */  {err, err, err},
           /* S3 */  {err, err, err},
           /* S4 */  {err, err,  g6},
           /* S5 */  {err, err,  g7},
           /* S6 */  {err, err, err},
           /* S7 */  {err, err, err},
           /* S8 */  {err, err, err},
           /* S9 */  {err, err, err}
         };
      // Change only abbreviations and table. Leave these methods alone.
      @SuppressWarnings("rawtypes")
      @Override
      public Parser.ActionTo getState(int state, Enum tok) {
         return srtable[state][tok.ordinal()]; //;
      }
      @SuppressWarnings("rawtypes")
      @Override
      public int _goto(int state, Enum nonterm) {
         return gototable[state][nonterm.ordinal()].to(); //;
      }
      @Override
      public int lastState() { return srtable.length - 1; }
   };

}
